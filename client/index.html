<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        let BOOKED_CODE; let BOOKING_KEY;
        // --BOOKING_MARK--

        /**
         * @returns {Promise<{ ws: WebSocket, code: string }>}
         */
        const createRoom = () => new Promise((resolve, reject) => {
            const ws = new WebSocket("/connect");
            ws.binaryType = "arraybuffer";

            ws.onmessage = (ev) => {
                resolve({ code: ev.data, ws })

                ws.onmessage = null;
                ws.onclose = null
            };

            ws.onclose = ({ code }) => {
                reject(code);
            }
        })

        /**
         * @param {string} roomCode
         * @param {string} [bookingKey]
         * @returns {Promise<WebSocket>}
         */
        const connectToRoom = (roomCode, bookingKey) => new Promise((resolve, reject) => {
            const ws = new WebSocket(`/connect?code=${roomCode}` + (bookingKey ? `&bookingKey=${bookingKey}` : ""));
                ws.binaryType = "arraybuffer";

                ws.onopen = () => {
                    ws.onopen = null;
                    ws.onerror = null;
                    resolve(ws)
                }

                ws.onclose = ({ code }) => {
                    Object.defineProperty(ws, "closeCode", {
                        value: code
                    })
                }

                ws.onerror = e => {
                    console.error(e);
                }
        })
        
        const searchParams = new URLSearchParams(location.search);
        const roomCode = searchParams.get("code");
        const roomKey = searchParams.get("key");
        const relayRoom = searchParams.get("relay");
        
        let roomTask;
        if(roomCode && roomKey && !relayRoom) {
            roomTask = connectToRoom(roomCode);
        } else if(!BOOKED_CODE) {
            roomTask = createRoom();
        }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.5.1/qrcode.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Noto+Sans+JP:wght@100..900&display=swap" rel="stylesheet">
    <title>Fast Chat</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: "Noto Sans JP", serif;
        }

        body {
            padding: 0;
            margin: 0;

            --black: #000;
            --dark-purple: #575068;
            --orange: #f29a30;
            --light-purple: #e1d8ef;

            background-color: var(--dark-purple);
        }
        .container {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;

            width: 100vw;
            height: 100vh;
        }

        .fade-in {
            animation: fade-in .3s forwards;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="stage === 'init'" class="container">
            <h2 class="fade-in" style="color: var(--light-purple); font-size: 32px;">Connecting</h2>
        </div>

        <div 
            id="content" 
            class="container" 
            style="display: none;" 
            @drop.prevent="handleDrop" 
            @dragover.prevent="showDragArea = true" 
            @dragleave.self="handleDragLeave"
        >
            <div v-if="showDragArea && stage === 'chat'" class="drag-area">
                Send Files
            </div>
            <div v-if="stage === 'creating'">
                <h2 class="fade-in" style="color: var(--light-purple); font-size: 32px;">Creating a room</h2>
            </div>
            <div v-if="stage === 'invite'" class="form" style="z-index: 1;">
                <h2 class="form-header">Room QR</h2>

                <img :src="qrCode" style="width: 100%;">

                <div :class="['form', 'relay-container', relayConnection ? 'relay-container--hidden' : 'relay-container--visible']">
                    <button class="form-button" @click="relayConnection = true">Relay connection</button>
                </div>
            </div>
            <form v-if="stage === 'chat'" class="form" @submit.prevent="sendMessage">
                <h2 class="form-header">Chat</h2>
                <div style="display: flex;">
                    <input class="form-input" placeholder="Enter message" v-model="input" @paste="handlePaste">
                    <label class="form-button form-file-input">
                        +
                        <input type="file" style="display: none;" multiple @change="attachFiles" />
                    </label>
                </div>
                <button class="form-button" style="margin-top: 10px;" type="submit">Send</button>
                <div class="messages">
                    <div 
                        v-for="message in messages" 
                        :class="{ 
                            message: true, 
                            'message-me': message.author === 'ME', 
                            'message-them': message.author === 'THEM' 
                        }"
                    >
                        <div v-if="message.type === 'text'" class="message-content">
                            {{ message.text }}
                        </div>
                        <div v-if="message.type === 'file'" class="message-content">
                            <div 
                                v-for="file in message.files" 
                                @click="file.type === 'RECEIVING' && download(file)" 
                                class="message-file"
                                :style="{ cursor: file.type === 'RECEIVING' && !!file.result ? 'pointer' : 'default' }"
                                :title="file.name"
                            >
                                <div class="message-file-name">{{ file.name }}</div>
                                <div class="message-file-progress">{{ (file.progress * 100).toFixed(2) }}%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
            <div v-if="stage === 'popup'" class="form" :style="!popup.message && !popup.showRestart ? { background: 'transparent' } : undefined">
                <h2 class="form-header">{{ popup.title }}</h2>
                <p v-if="popup.message" style="color: var(--dark-purple); text-align: center; font-size: 20px;">
                    {{ popup.message }}
                </p>
                <button v-if="popup.showRestart" class="form-button" @click="popup.buttonClickCb()">{{ popup.buttonText }}</button>
            </div>
        </div>
    </div>
    <script>
        // Helpers
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();

        /**
         * @returns {Promise<{ key: CryptoKey, base64: string }>}
         */
        const createKey = () => new Promise(async (resolve, reject) => {
            const key = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 128 },
                true,
                ['encrypt', 'decrypt'],
            );

            const keyBytes = await crypto.subtle.exportKey("raw", key);

            const blob = new Blob([keyBytes], { type: 'application/octet-binary' });

            const reader = new FileReader();

            reader.onload = (e) => {
                resolve({
                    key, 
                    base64: e.target.result.split(',')[1]
                })
            }

            reader.readAsDataURL(blob);
        })

        const decodeBase64 = async (base64) => {
            const dataURL = `data:application/octet-bytes;base64,` + base64;

            const res = await fetch(dataURL);

            const bytes = await res.arrayBuffer();

            return bytes;
        }

        const readKey = async (keyMaterial) => {
            const bytes = await decodeBase64(keyMaterial);

            return crypto.subtle.importKey(
                "raw",
                bytes,
                { name: 'AES-GCM', length: 128 },
                false,
                ['encrypt', 'decrypt'],
            )
        }

        /**
         * @param {Array<number | Uint8Array | ArrayBuffer>} args
         * @returns {ArrayBuffer}
         */
         const composeBuffer = (...args) => {
            let size = 0;

            for(const elem of args) {
                if(typeof elem === "number") {
                    size += 1;
                } else {
                    size += elem.byteLength;
                }
            }

            const composed = new Uint8Array(size);

            let offset = 0;
            for(const elem of args) {
                if(typeof elem === "number") {
                    composed[offset] = elem;
                    offset += 1;
                } else if(elem instanceof Uint8Array){
                    composed.set(elem, offset);
                    offset += elem.byteLength;
                } else {
                    composed.set(new Uint8Array(elem), offset);
                    offset += elem.byteLength;
                }
            }

            return composed.buffer;
        }

        /**
         * @param {CryptoKey} key
         * @param {ArrayBuffer} data
         * @returns {Promise<ArrayBuffer>}
         */
        const encryptPacket = async (key, data) => {
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const cipherText = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                key,
                data
            )

            return composeBuffer(iv, cipherText)
        }

        const decryptPacket = async (key, message) => {
            const iv = message.slice(0, 12);
            const cipherText = message.slice(12);

            return crypto.subtle.decrypt(
                { name: "AES-GCM", iv },
                key,
                cipherText
            )
        }

        const readDataFromWs = (ws) => new Promise((resolve, reject) => {
            ws.onmessage = ({ data }) => {
                resolve(data);
                ws.onmessage = null;
                ws.onclose = null;
            }

            ws.onclose = (code) => {
                ws.onmessage = null;
                ws.onclose = null;
                reject(code)
            }
        })

        const generateECDH = async () => {
            const { privateKey, publicKey } = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: 'P-256',
                },
                true,
                ['deriveKey'],
            );

            const exportedPublicKey = await crypto.subtle.exportKey("raw", publicKey);

            return {
                privateKey,
                publicKey: exportedPublicKey
            }
        }

        const deriveAESKey = async (publicKeyBytes, privateKey) => {
            const theirPublicKey = await crypto.subtle.importKey(
                "raw", 
                publicKeyBytes,
                { name: "ECDH", namedCurve: 'P-256' },
                false,
                []
            )

            return crypto.subtle.deriveKey(
                {
                    name: "ECDH",
                    public: theirPublicKey
                },
                privateKey,
                {
                    name: 'AES-GCM',
                    length: 128,
                },
                false,
                ['encrypt', 'decrypt'],
            )
        }


        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const loadImage = (url, type) => new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;

                ctx.clearRect(0, 0, img.width, img.height);

                ctx.drawImage(img, 0, 0);

                const dataUrl = canvas.toDataURL(type);

                fetch(dataUrl)
                    .then(r => r.arrayBuffer())
                    .then(resolve)
            }

            img.onerror = reject;

            img.src = url;
        })
    </script>
    <script>
        /**
         * @typedef {{
         *   author: "ME" | "THEM",
         *   type: "text",
         *   text: string
         * }} TextMessage
         * 
         * @typedef {{
         *   author: "ME" | "THEM",
         *   type: "file",
         *   caption: string
         *   files: FileTransferView[],
         * }} FileMessage
         * 
         * @typedef {{
         *   type: "SENDING" | "RECEIVING",
         *   name: string,
         *   groupID: number,
         *   index: number,
         *   progress: number
         *   result: null | {
         *      type: string,
         *      url: string
         *   }
         * }} FileTransferView
         * 
         * 
         * @typedef Sender
         * @property {ArrayBuffer} buffer
         * @property {FileTransferView} view
         * @property {number} transferred
         * @property {number} total
         * @property {number} groupID
         * @property {number} index
         * 
         * @typedef Receiver
         * @property {Uint8Array} buffer
         * @property {FileTransferView} view
         * @property {number} transferred
         * @property {number} total
         * @property {number} groupID
         * @property {number} index
         * @property {string} type
         */

        const PACKET_CONFIRM_TIMEOUT = 10000;
        const NO_CONFIRM = true;
        const MAX_PACKET_SIZE = 1024 * 1024 / 2

        let idCounter = 0;

        const PACKET_TYPE = {
            CHAT: 0,
            CONFIRM: 1,
            FILE_INIT: 2,
            FILE_CHUNK: 3,
            FILE_CANCEL: 4, 
        }

        /** @type {Map<number, number>} */
        const confirmTimeouts = new Map();

        /** @type {Map<number, Array<{ index: number, name: string, type: string, content: ArrayBuffer }>} */
        const awaitingFileTransfers = new Map();
        
        /** @type {Map<number, Sender>} */
        const inProgressSender = new Map();

        /** @type {Map<number, Map<number, Receiver>>} */
        const activeReceivers = new Map();

        /** @type {Map<number, Map<number, { file: File, url: string }>>} */
        const filesDB = new Map();

        const app = Vue.createApp({
            data() {
                return {
                    stage: "init",
                    baseInviteUrl: null,
                    messages: [],
                    input: "",
                    relayConnection: false,
                    qrCode: null,
                    popup: {
                        title: "",
                        message: "",
                        showRestart: true,
                        buttonText: "Restart",
                        buttonClickCb: this.createRoom
                    },
                    showDragArea: false,
                    fileTransfers: [],
                }
            },
            computed: {
                inviteUrl() {
                    if(this.relayConnection) {
                        return this.baseInviteUrl + "&relay=true"
                    }

                    return this.baseInviteUrl;
                },
            },
            watch: {
                async inviteUrl(url) {
                    console.log(url);

                    this.qrCode = await QRCode.toDataURL(url, {
                        type: 'image/png',
                        color: {
                            dark: "#575068",
                            light: "#e1d8ef"
                        }
                    });
                }
            },
            methods: {
                async createRoom(initialTask) {
                    this.stage = 'creating';

                    this.relayConnection = false;
                    try {
                        const [{ key, base64 }, { code, ws }] = await Promise.all([
                            createKey(),
                            initialTask ?? createRoom()
                        ]);

                        const url = new URL(location.origin);
                        url.searchParams.set("code", code);
                        url.searchParams.set("key", base64);

                        this.baseInviteUrl = url.toString();

                        this.stage = "invite"

                        this.waitForGuest(ws, key);
                    } catch(e) {
                        if(e === 4001) {
                            this.displayPopup("Error", "No rooms left");
                        } else {
                            this.displayPopup("Error", "Something went wrong");
                            console.error(e);
                        }
                    }
                },
                async connectBooked(roomCode, bookingKey) {
                    const connectionTask = connectToRoom(roomCode, bookingKey);
                    const { base64, key } = await createKey();

                    const url = new URL(location.origin);
                    url.searchParams.set("code", roomCode);
                    url.searchParams.set("key", base64);

                    this.baseInviteUrl = url.toString();

                    this.stage = "invite"

                    const ws = await connectionTask;

                    this.waitForGuest(ws, key);
                },
                async waitForGuest(ws, key) {
                    const hello = new Uint8Array(await decryptPacket(key, await readDataFromWs(ws)));

                    if(hello.slice(0, 3).join("") !== '101') {
                        console.error("Fake hello");
                        return;
                    }

                    if(this.relayConnection) {
                        if(hello.length !== 4) {
                            console.error("Fake hello");
                            return;
                        }

                        const relayMessageType = hello[3];

                        if(relayMessageType === 0) { // we are to start negotiation
                            this.startNegotiation(key, ws);
                        } else { // we are the target of negotiation
                            this.acceptNegotiation(key, ws);
                        }
                    } else {
                        if(hello.length !== 3) {
                            console.error("Fake hello");
                            return;
                        }
                        this.setUpChat(key, ws);
                    }

                    ws.send(await encryptPacket(key, Uint8Array.of(1, 0, 1)))
                },
                /**
                 * @param {Promise<WebSocket>} roomConnectionTask
                 */
                async connect(roomConnectionTask, keyMaterial) {
                    try {
                        const [ws, key] = await Promise.all([
                            roomConnectionTask,
                            readKey(keyMaterial),
                        ])

                        if(ws.readyState === ws.CLOSED || ws.readyState === ws.CLOSING) {
                            if(ws.closeCode === 4002) {
                                this.displayPopup("Error", "Room not found");
                            } else if(ws.closeCode === 4004) {
                                this.displayPopup(
                                    "Error", 
                                    "Room was not initialized yet", 
                                    true, 
                                    "Try again", 
                                    () => location.reload()
                                );
                            } else {
                                this.displayPopup("Error", "Something went wrong");
                            }

                            return;
                        }

                        ws.send(await encryptPacket(key, Uint8Array.of(1, 0, 1)))

                        const message = await decryptPacket(key, await readDataFromWs(ws));

                        if(new Uint8Array(message).join("") !== '101') {
                            console.error("Fake hello");
                            return;
                        }

                        this.setUpChat(key, ws);
                    } catch(e) {
                        this.displayPopup("Error", "Something went wrong");
                        console.error(e);
                    }
                },
                async initRelay(code, keyMaterial) {
                    let savedInvite;

                    try {
                        savedInvite = JSON.parse(localStorage.getItem("relayData"));
                    } catch {
                        savedInvite = null;
                    }

                    if(!savedInvite || Date.now() - savedInvite.date > 10 * 60 * 1000) {
                        localStorage.setItem("relayData", JSON.stringify({ code, keyMaterial, date: Date.now() }));

                        this.displayPopup(
                            "Relay initiated", 
                            "Scan second QR code to connect devices", 
                            true,
                            "Cancel",
                            () => {
                                localStorage.removeItem("relayData");

                                this.displayPopup("Connection stopped", null, false);
                            }
                        );

                        return;
                    }

                    this.displayPopup("Connecting devices...", null, false);

                    localStorage.removeItem("relayData");

                    const [ws, key, targetKeyBytes] = await Promise.all([
                        connectToRoom(code),
                        readKey(keyMaterial),
                        decodeBase64(savedInvite.keyMaterial)
                    ]);

                    const targetRoomCode = encoder.encode(savedInvite.code);

                    ws.send(await encryptPacket(key, Uint8Array.of(1, 0, 1, 0))); // 0 you are to start the negotiation

                    const message = await decryptPacket(key, await readDataFromWs(ws));

                    if(new Uint8Array(message).join("") !== '101') {
                        console.error("Fake hello");
                        return;
                    }

                    const payload = new Uint8Array(targetKeyBytes.byteLength + targetRoomCode.byteLength);

                    payload.set(targetRoomCode);
                    payload.set(new Uint8Array(targetKeyBytes), targetRoomCode.byteLength);

                    ws.send(await encryptPacket(key, payload.buffer));
                    ws.close();

                    this.displayPopup("Invites are sent", "Check connecting devices", false);
                },
                /**
                 * @param {WebSocket} relayWs
                 */
                async startNegotiation(relayKey, relayWs) {
                    this.displayPopup("Connecting...", null, false);

                    const targetData = new Uint8Array(await decryptPacket(relayKey, await readDataFromWs(relayWs)));
                    if(relayWs.readyState !== relayWs.CLOSED) {
                        relayWs.close();
                    }
                    
                    const code = decoder.decode(targetData.slice(0, 4));
                    const rawKeyBytes = targetData.slice(4);

                    const ecdhTask = generateECDH();

                    const [ws, key] = await Promise.all([
                        connectToRoom(code),
                        crypto.subtle.importKey(
                            "raw",
                            rawKeyBytes,
                            { name: 'AES-GCM', length: 128 },
                            false,
                            ['encrypt', 'decrypt'],
                        )
                    ])

                    ws.send(await encryptPacket(key, Uint8Array.of(1, 0, 1, 1))) // 1 for we are starting the negotiation

                    while(true) {
                        const hello = await decryptPacket(key, await readDataFromWs(ws));

                        if(new Uint8Array(hello).join("") !== "101") {
                            console.error("Fake hello");
                            continue;
                        }

                        break;
                    }

                    const { privateKey, publicKey } = await ecdhTask;

                    ws.send(await encryptPacket(key, publicKey));

                    const theirPublicKeyBytes = await decryptPacket(key, await readDataFromWs(ws));

                    const newKey = await deriveAESKey(theirPublicKeyBytes, privateKey);

                    this.setUpChat(newKey, ws);
                },
                async acceptNegotiation(key, ws) {
                    this.displayPopup("Connecting...", null, false);

                    const [{ privateKey, publicKey }, theirPublicKeyBytes] = await Promise.all([
                        generateECDH(),
                        readDataFromWs(ws)
                            .then(data => decryptPacket(key, data))
                    ]);

                    ws.send(await encryptPacket(key, publicKey));

                    const newKey = await deriveAESKey(theirPublicKeyBytes, privateKey);
                    
                    this.setUpChat(newKey, ws);
                },
                async setUpChat(key, ws) {
                    this.ws = ws;
                    this.key = key;
                    this.messages = [];

                    this.stage = "chat";

                    this.ws.onmessage = async ({ data }) => {
                        const packet = await decryptPacket(key, data);
                        
                        const packetBody = new Uint8Array(packet.slice(4));

                        if(packetBody[0] !== PACKET_TYPE.CONFIRM) {
                            // TODO: later add CONFIRM_CONFIRM
                            this.sendPacket(PACKET_TYPE.CONFIRM, packet.slice(0, 4), NO_CONFIRM);
                        }

                        switch(packetBody[0]) {
                            case PACKET_TYPE.CONFIRM:
                                const confirmID = new Uint32Array(packet.slice(5), 0, 1)[0];
                                clearTimeout(confirmTimeouts.get(confirmID));
                                confirmTimeouts.delete(confirmID);

                                if(awaitingFileTransfers.has(confirmID)) {
                                    const files = awaitingFileTransfers.get(confirmID);
                                    awaitingFileTransfers.delete(confirmID);
                                    this.startTransferringProcess(confirmID, files);
                                }

                                if(inProgressSender.has(confirmID)) {
                                    const sender = inProgressSender.get(confirmID);
                                    inProgressSender.delete(confirmID);
                                    this.sendNextChunk(sender);
                                }

                                break;

                            case PACKET_TYPE.CHAT:
                                /** @type {TextMessage} */
                                const newMessage = {
                                    author: "THEM",
                                    type: "text",
                                    text: decoder.decode(packetBody.slice(1))
                                };

                                this.messages.push(newMessage);
                                break;
                            
                            case PACKET_TYPE.FILE_INIT:
                                // initial packet ID used as group identifier
                                const groupID = new Uint32Array(packet.slice(0, 4), 0, 1)[0];

                                const files = [];
                                let offset = 1;
                                
                                let index = 0;
                                while(true) {
                                    if(offset === packetBody.length) break;
                                    
                                    const nameLength = packetBody[offset];
                                    offset += 1;
                                    const name = packetBody.slice(offset, offset + nameLength);
                                    offset += nameLength;

                                    const typeLength = packetBody[offset];
                                    offset += 1;
                                    const type = packetBody.slice(offset, offset + typeLength);
                                    offset += typeLength;

                                    const fileSize = new Uint32Array(packetBody.slice(offset).buffer, 0, 1)
                                    offset += 4;
                                    
                                    files.push({
                                        index: index++,
                                        name: decoder.decode(name),
                                        type: decoder.decode(type),
                                        size: fileSize[0],
                                    })
                                }

                                this.prepareForIncomingFiles(groupID, files);

                                break;

                            case PACKET_TYPE.FILE_CHUNK:
                                const fileGroup = new Uint32Array(packet.slice(5), 0, 1)[0];
                                const fileIndex = packetBody[5];


                                const receiver = activeReceivers.get(fileGroup)?.get(fileIndex);

                                if(!receiver) {
                                    console.error(`Unexpected file with group ${fileGroup} and index ${fileIndex}`);
                                    return;
                                }

                                const chunk = packetBody.slice(6);

                                this.handleIncomingChunk(receiver, chunk);

                                break;
                                
                            default:
                                console.log("UNKNOWN", packetBody);
                        }
                    }

                    this.ws.onclose = ({ code }) => {
                        if(code === 1000) {
                            this.displayPopup("Chat closed", "Other party has left the room");
                        } else {
                            this.displayPopup("Chat closed", "Network error");
                        }
                    }
                },
                async sendMessage() {
                    if(!this.input) return;
                    
                    this.sendPacket(PACKET_TYPE.CHAT, encoder.encode(this.input));

                    this.messages.push({ author: "ME", type: 'text', text: this.input });

                    this.input = "";
                },
                /**
                 * @param {number} packetType
                 * @param {ArrayBuffer} packetBody 
                 * @param {boolean} [noConfirm=false]
                 * @param {number} ID
                 * @returns {Promise<number>} sent packet ID
                 */
                async sendPacket(packetType, packetBody, noConfirm = false, ID = idCounter++) {
                    const id = Uint32Array.of(ID);

                    this.ws.send(await encryptPacket(this.key, composeBuffer(id.buffer, packetType, packetBody)));

                    if(noConfirm) return ID;

                    confirmTimeouts.set(
                        ID, 
                        setTimeout(() => {
                            confirmTimeouts.delete(id);
                            this.sendPacket(packetType, packetBody, undefined, ID);
                        }, PACKET_CONFIRM_TIMEOUT)
                    )

                    return ID;
                },
                displayPopup(title, message, showRestart = true, buttonText = "Restart", buttonClickCb = this.createRoom) {
                    this.stage = "popup";

                    this.popup.title = title;
                    this.popup.message = message;
                    this.popup.showRestart = showRestart;
                    this.popup.buttonText = buttonText;
                    this.popup.buttonClickCb = buttonClickCb;
                },
                /**
                 * @param {ClipboardEvent} e 
                 */
                handlePaste(e) {
                    if(e.clipboardData.files.length === 0) return;
                    e.preventDefault();
                    this.sendFiles(Array.from(e.clipboardData.files));
                },
                /**
                 * @param {DragEvent} e
                 */
                async handleDrop(e) {
                    this.showDragArea = false;
                    if(this.stage !== "chat") return;

                    this.sendFiles(Array.from(e.dataTransfer.files));
                },
                /**
                 * @param {DragEvent} e
                 */
                async handleDragLeave(e) {
                    if(!e.relatedTarget) this.showDragArea = false;
                },
                async sendFiles(filesToSend) {
                    let currentIndex = 0;
                    const encodedFiles = [];

                    const files = await Promise.all(
                        filesToSend
                            .filter(f => !!f.type)
                            .map(async (file) => {
                                const url = URL.createObjectURL(file);
                                let buffer;
                                if(file.type.startsWith("image/") && !file.type.endsWith("gif")) {
                                    buffer = await loadImage(url, file.type);
                                } else if(file.type.startsWith("text/")) {
                                    buffer = encoder.encode(await fetch(url).then(r => r.text()));
                                } else {
                                    buffer = await fetch(url).then(r => r.arrayBuffer());
                                }

                                URL.revokeObjectURL(url);

                                encodedFiles.push(file.name.length);
                                encodedFiles.push(encoder.encode(file.name));
                                encodedFiles.push(file.type.length);
                                encodedFiles.push(encoder.encode(file.type));
                                encodedFiles.push(Uint32Array.of(buffer.byteLength).buffer);

                                return {
                                    index: currentIndex++,
                                    name: file.name,
                                    type: file.type,
                                    content: buffer
                                }
                            })
                    )

                    const groupID = await this.sendPacket(PACKET_TYPE.FILE_INIT, composeBuffer(...encodedFiles));

                    awaitingFileTransfers.set(groupID, files);
                },
                async startTransferringProcess(groupID, files) {
                    /** @type {FileMessage} */
                    const originalMessage = {
                        author: "ME",
                        caption: "",
                        type: "file",
                        files: files.map(file => ({
                            type: "SENDING",
                            groupID,
                            index: file.index,
                            name: file.name,
                            progress: 0,
                        }))
                    }
                    this.messages.push(originalMessage);

                    /** @type {FileMessage} */
                    const messageView = this.messages[this.messages.length - 1];

                    for(let i = 0; i < messageView.files.length; i++) {
                        const fileView = messageView.files[i];
                        /** @type {{ content: ArrayBuffer, index: number }} */
                        const file = files[i];

                        /** @type {Sender} */
                        const sender = {
                            buffer: file.content,
                            view: fileView,
                            transferred: 0,
                            total: file.content.byteLength,
                            groupID,
                            index: file.index
                        }

                        this.sendNextChunk(sender);
                    }
                },
                async prepareForIncomingFiles(groupID, files) {
                    /** @type {FileMessage} */
                    const originalMessage = {
                        author: "THEM",
                        caption: "",
                        type: "file",
                        files: files.map(file => ({
                            type: "RECEIVING",
                            groupID,
                            index: file.index,
                            name: file.name,
                            progress: 0,
                        }))
                    }

                    this.messages.push(originalMessage);

                    /** @type {FileMessage} */
                    const messageView = this.messages[this.messages.length - 1];


                    const groupMap = new Map();
                    activeReceivers.set(groupID, groupMap);

                    for(let i = 0; i < messageView.files.length; i++) {
                        const fileView = messageView.files[i];
                        /** @type {{ index: number, size: number, type: string }} */
                        const file = files[i];

                        /** @type {Receiver} */
                        const receiver = {
                            buffer: new Uint8Array(file.size),
                            view: fileView,
                            transferred: 0,
                            total: file.size,
                            groupID,
                            index: file.index,
                            type: file.type
                        }

                        groupMap.set(file.index, receiver);
                    }
                },
                /** @param {Sender} sender */
                async sendNextChunk(sender) {
                    sender.view.progress = sender.transferred / sender.total;

                    if(sender.transferred === sender.total) {
                        // TODO: do smth when transferred.
                        return;
                    }

                    const chunk = sender.buffer.slice(sender.transferred, sender.transferred + MAX_PACKET_SIZE);

                    let nextTransferred = sender.transferred + MAX_PACKET_SIZE;
                    if(nextTransferred > sender.total) {
                        nextTransferred = sender.total;
                    }
                    sender.transferred = nextTransferred;
                    
                    const packetID = await this.sendPacket(
                        PACKET_TYPE.FILE_CHUNK, 
                        composeBuffer(Uint32Array.of(sender.groupID).buffer, sender.index, chunk)
                    );

                    inProgressSender.set(packetID, sender);
                },
                /**
                 * @param {Receiver} receiver
                 * @param {Uint8Array} chunk 
                 */
                handleIncomingChunk(receiver, chunk) {
                    receiver.buffer.set(chunk, receiver.transferred);

                    receiver.transferred += chunk.byteLength;

                    receiver.view.progress = receiver.transferred / receiver.total;

                    if(receiver.transferred === receiver.total) {
                        const group = activeReceivers.get(receiver.groupID);
                        group.delete(receiver.index);
                        if(group.size === 0) {
                            activeReceivers.delete(receiver.groupID);
                        }

                        const file = new File([receiver.buffer], receiver.view.name, {
                            type: receiver.type
                        });

                        const url = URL.createObjectURL(file)

                        let groupDB = filesDB.get(receiver.groupID);
                        if(!groupDB) {
                            groupDB = new Map();
                            filesDB.set(receiver.groupID, groupDB);
                        }

                        groupDB.set(receiver.index, {
                            file,
                            url
                        })

                        receiver.view.result = {
                            type: receiver.type,
                            url
                        }
                        
                        console.log("DONE");
                        return;
                    }

                    if(receiver.transferred > receiver.total) {
                        const group = activeReceivers.get(receiver.groupID);
                        group.delete(receiver.index);
                        if(group.size === 0) {
                            activeReceivers.delete(receiver.groupID);
                        }

                        console.error("ERROR");
                        return;
                    }
                },
                /** @param {FileTransferView} file */
                download(file) {
                    if(!file.result) return;
                    const a = document.createElement("a");
                    a.href = file.result.url;
                    a.download = file.name;
                    a.click();
                },
                attachFiles(e) {
                    if(e.target.files.length === 0) return;
                    this.sendFiles(Array.from(e.target.files));
                }
            },
            async mounted() {
                document.getElementById('content').style.display = 'flex';

                if(BOOKED_CODE) {
                    this.connectBooked(BOOKED_CODE, BOOKING_KEY);
                    return;
                }

                if(!roomCode) {
                    this.createRoom(roomTask);
                    return;
                }

                if(relayRoom) this.initRelay(roomCode, roomKey)
                else this.connect(roomTask, roomKey);
            }
        })

        app.mount("#app")
    </script>
    <style>
        .drag-area {
            position: fixed;

            top: 0;
            left: 0;

            width: 100vw;
            height: 100vh;

            background-color: rgba(0, 0, 0, .7);

            z-index: 2;

            pointer-events: none;

            display: flex;
            align-items: center;
            justify-content: center;

            color: var(--light-purple);
            font-size: 30px;
            font-weight: 600;

            animation: slide-in .3s;
        }

        .form {
            background-color: var(--light-purple);

            width: 400px;

            padding: 10px;

            border-radius: 20px;

            position: relative;

            animation: slide-in .7s;
        }

        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media screen and (max-width: 400px) {
            .form {
                width: 100vw;

                border-radius: 0;
            }

            .message {
                padding: 0 10px;
            }
        }

        .form-header {
            position: absolute;
            bottom: calc(100% + 15px);
            left: 0;

            width: 100%;

            color: var(--light-purple);
            font-size: 32px;
            line-height: 30px;
            margin: 0;
            text-align: center;

            position: absolute;
        }

        .form-button {
            display: block;

            width: 100%;

            border: none;
            border-radius: 20px;

            text-align: center;
            font-size: 20px;
            padding: 12px 0;
            color: var(--orange);

            background-color: var(--dark-purple);

            cursor: pointer;

            transition: color .3s, background .3s, transform .3s, box-shadow .3s;
        }

        .form-button:hover {
            background-color: var(--orange);
            color: var(--dark-purple);
            transform: translateY(-5px);
            box-shadow: 0 5px 0 var(--dark-purple);
        }

        .form-button:active {
            background-color: var(--orange);
            color: var(--dark-purple);
            transform: translateY(0px);
            box-shadow: 0 0 0 var(--dark-purple);
        }

        .form-input {
            width: calc(100% - 57px);

            background-color: var(--dark-purple);

            border: 2px solid var(--dark-purple);

            border-radius: 20px;

            outline: none;

            font-size: 20px;
            color: var(--orange);

            padding: 10px 15px;

            transition: border .3s;
        }

        .form-input:focus {
            border: 2px solid var(--orange);
        }

        .form-file-input {
            margin-left: 10px;

            height: 47px;
            width: 47px;

            border-radius: 50%;

            background-color: var(--dark-purple);

            cursor: pointer;

            display: flex;
            align-items: center;
            justify-content: center;
            
            color: var(--light-purple);
            font-size: 40px;

            padding: 0 0 5px;
        }

        .relay-container {
            position: absolute;
            left: 0;
            top: calc(100% + 10px);

            width: 100%;

            transition: transform .3s, opacity .3s;
        }

        .relay-container--visible {
            transform: translateY(0);
            opacity: 1;
        }

        .relay-container--hidden {
            transform: translateY(10px);
            opacity: 0;
        }

        .form-checkbox {
            cursor: pointer;

            display: flex;
            align-items: center;
            
            user-select: none;
        }

        .form-checkbox input[type="checkbox"] {
            display: none;
        }

        .checkbox-view {
            width: 20px;
            height: 20px;

            background-color: var(--dark-purple);
            border-radius: 50%;

            position: relative;
        }

        .checkbox-view::after {
            content: "";
            display: block;

            position: absolute;
            top: 5px;
            left: 5px;
            
            width: 10px;
            height: 10px;

            border-radius: 50%;

            background: transparent;
        }

        input[type="checkbox"]:checked + .checkbox-view::after {
            background-color: var(--orange);
        }

        .form-checkbox span {
            margin-left: 10px;

            color: var(--dark-purple);
            font-size: 16px;

            padding-bottom: 2px;
        }

        .messages {
            position: absolute;
            width: 100%;
            left: 0;
            bottom: calc(100% + 60px);
        }

        .message {
            width: 100%;

            display: flex;
            
            font-size: 16px;

            animation: message-pop .5s forwards;
        }

        @keyframes message-pop {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message:not(:first-child) {
            margin-top: 10px;
        }

        .message-me {
            justify-content: flex-end;

            color: var(--orange);
        }

        .message-them {
            justify-content: flex-start;

            color: var(--dark-purple);
        }

        .message-them .message-content {
            background-color: var(--light-purple);
        }

        .message-content {
            max-width: 70%;

            padding: 10px 15px;

            border-radius: 20px;

            box-shadow: 0 4px 0 1px black;

            border: 2px solid var(--light-purple);

            word-wrap: break-word;
        }

        .message-file {
            padding: 10px 15px;

            border-radius: 13px;

            width: 100%;

            display: flex;
            align-items: center;
            justify-content: space-between;

            background-color: var(--orange);

            box-shadow: 0 4px 0 1px black;

            transform: translateY(-4px);
        }

        .message-me .message-file {
            color: var(--dark-purple);
        }

        .message-file:not(:first-child) {
            margin-top: 10px;
        }

        .message-file-name {
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }


        .message-file-progress {
            margin-left: 10px;
        }
    </style>
</body>
</html>