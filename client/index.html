<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.5.1/qrcode.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Noto+Sans+JP:wght@100..900&display=swap" rel="stylesheet">
    <title>Fast Chat</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: "Noto Sans JP", serif;
        }

        body {
            padding: 0;
            margin: 0;

            --black: #000;
            --dark-purple: #575068;
            --orange: #f29a30;
            --light-purple: #e1d8ef;

            background-color: var(--dark-purple);
        }
        .container {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;

            width: 100vw;
            height: 100vh;
        }

        .fade-in {
            animation: fade-in .3s forwards;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="stage === 'init'" class="container">
            <h2 class="fade-in" style="color: var(--light-purple); font-size: 32px;">Connecting</h2>
        </div>

        <div id="content" class="container" style="display: none;">
            <div v-if="stage === 'creating'">
                <h2 class="fade-in" style="color: var(--light-purple); font-size: 32px;">Creating a room</h2>
            </div>
            <div v-if="stage === 'invite'" class="form" style="z-index: 1;">
                <h2 class="form-header">Room QR</h2>

                <img :src="qrCode" style="width: 100%;">

                <div :class="['form', 'relay-container', relayConnection ? 'relay-container--hidden' : 'relay-container--visible']">
                    <button class="form-button" @click="relayConnection = true">Relay connection</button>
                </div>
            </div>
            <form v-if="stage === 'chat'" class="form" @submit.prevent="sendMessage">
                <h2 class="form-header">Chat</h2>
                <input class="form-input" placeholder="Enter message" v-model="input">
                <button class="form-button" style="margin-top: 10px;" type="submit">Send</button>
                <div class="messages">
                    <div v-for="message in messages" :class="{ message: true, 'message-me': message.author === 'ME', 'message-them': message.author === 'THEM' }">
                        <div class="message-content">
                            {{ message.text }}
                        </div>
                    </div>
                </div>
            </form>
            <div v-if="stage === 'popup'" class="form" :style="!popup.message && !popup.showRestart ? { background: 'transparent' } : undefined">
                <h2 class="form-header">{{ popup.title }}</h2>
                <p v-if="popup.message" style="color: var(--dark-purple); text-align: center; font-size: 20px;">
                    {{ popup.message }}
                </p>
                <button v-if="popup.showRestart" class="form-button" @click="popup.buttonClickCb">{{ popup.buttonText }}</button>
            </div>
        </div>
    </div>
    <script>
        // Helpers
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();

        /**
         * @returns {Promise<{ ws: WebSocket, code: string }>}
         */
        const createRoom = () => new Promise((resolve, reject) => {
            const ws = new WebSocket("/connect");
            ws.binaryType = "arraybuffer";

            ws.onmessage = (ev) => {
                resolve({ code: ev.data, ws })

                ws.onmessage = null;
                ws.onclose = null
            };

            ws.onclose = ({ code }) => {
                reject(code);
            }
        })

        /**
         * @param {string} code
         * @returns {Promise<WebSocket>}
         */
        const connectToRoom = (code) => new Promise((resolve, reject) => {
            const ws = new WebSocket(`/connect?code=${code}`);
            ws.binaryType = "arraybuffer";

            ws.onopen = () => {
                resolve(ws)
            }

            ws.error = (error) => {
                reject(code)
            }
        })

        /**
         * @returns {Promise<{ key: CryptoKey, base64: string }>}
         */
        const createKey = () => new Promise(async (resolve, reject) => {
            const key = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 128 },
                true,
                ['encrypt', 'decrypt'],
            );

            const keyBytes = await crypto.subtle.exportKey("raw", key);

            const blob = new Blob([keyBytes], { type: 'application/octet-binary' });

            const reader = new FileReader();

            reader.onload = (e) => {
                resolve({
                    key, 
                    base64: e.target.result.split(',')[1]
                })
            }

            reader.readAsDataURL(blob);
        })

        const decodeBase64 = async (base64) => {
            const dataURL = `data:application/octet-bytes;base64,` + base64;

            const res = await fetch(dataURL);

            const bytes = await res.arrayBuffer();

            return bytes;
        }

        const readKey = async (keyMaterial) => {
            const bytes = await decodeBase64(keyMaterial);

            return crypto.subtle.importKey(
                "raw",
                bytes,
                { name: 'AES-GCM', length: 128 },
                false,
                ['encrypt', 'decrypt'],
            )
        }

        /**
         * @param {CryptoKey} key
         * @param {ArrayBuffer} data
         * @returns {Promise<ArrayBuffer>}
         */
        const createMessage = async (key, data) => {
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const cipherText = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                key,
                data
            )

            const result = new Uint8Array(iv.byteLength + cipherText.byteLength);

            result.set(iv, 0);
            result.set(new Uint8Array(cipherText), 12);

            return result.buffer;
        }

        const parseMessage = async (key, message) => {
            const iv = message.slice(0, 12);
            const cipherText = message.slice(12);

            return crypto.subtle.decrypt(
                { name: "AES-GCM", iv },
                key,
                cipherText
            )
        }

        const readDataFromWs = (ws) => new Promise((resolve, reject) => {
            ws.onmessage = ({ data }) => {
                resolve(data);
                ws.onmessage = null;
                ws.onclose = null;
            }

            ws.onclose = (code) => {
                ws.onmessage = null;
                ws.onclose = null;
                reject(code)
            }
        })

        const generateECDH = async () => {
            const { privateKey, publicKey } = await crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: 'P-256',
                },
                true,
                ['deriveKey'],
            );

            const exportedPublicKey = await crypto.subtle.exportKey("raw", publicKey);

            return {
                privateKey,
                publicKey: exportedPublicKey
            }
        }

        const deriveAESKey = async (publicKeyBytes, privateKey) => {
            const theirPublicKey = await crypto.subtle.importKey(
                "raw", 
                publicKeyBytes,
                { name: "ECDH", namedCurve: 'P-256' },
                false,
                []
            )

            return crypto.subtle.deriveKey(
                {
                    name: "ECDH",
                    public: theirPublicKey
                },
                privateKey,
                {
                    name: 'AES-GCM',
                    length: 128,
                },
                false,
                ['encrypt', 'decrypt'],
            )
        }
    </script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    stage: "init",
                    baseInviteUrl: null,
                    messages: [],
                    input: "",
                    relayConnection: false,
                    qrCode: null,
                    popup: {
                        title: "",
                        message: "",
                        showRestart: true,
                        buttonText: "Restart",
                        buttonClickCb: this.createRoom
                    }
                }
            },
            computed: {
                inviteUrl() {
                    if(this.relayConnection) {
                        return this.baseInviteUrl + "&relay=true"
                    }

                    return this.baseInviteUrl;
                },
            },
            watch: {
                async inviteUrl(url) {
                    console.log(url);

                    this.qrCode = await QRCode.toDataURL(url, {
                        type: 'image/png',
                        color: {
                            dark: "#575068",
                            light: "#e1d8ef"
                        }
                    });
                }
            },
            methods: {
                async createRoom() {
                    this.relayConnection = false;
                    try {
                        const [{ key, base64 }, { code, ws }] = await Promise.all([
                            createKey(),
                            createRoom()
                        ]);

                        const url = new URL(location.origin);
                        url.searchParams.set("code", code);
                        url.searchParams.set("key", base64);

                        this.baseInviteUrl = url.toString();

                        this.stage = "invite"

                        const hello = new Uint8Array(await parseMessage(key, await readDataFromWs(ws)));

                        if(hello.slice(0, 3).join("") !== '101') {
                            console.error("Fake hello");
                            return;
                        }

                        if(this.relayConnection) {
                            if(hello.length !== 4) {
                                console.error("Fake hello");
                                return;
                            }

                            const relayMessageType = hello[3];

                            if(relayMessageType === 0) { // we are to start negotiation
                                this.startNegotiation(key, ws);
                            } else { // we are the target of negotiation
                                this.acceptNegotiation(key, ws);
                            }
                        } else {
                            if(hello.length !== 3) {
                                console.error("Fake hello");
                                return;
                            }
                            this.setUpChat(key, ws);
                        }

                        ws.send(await createMessage(key, Uint8Array.of(1, 0, 1)))
                    } catch(e) {
                        if(e === 4001) {
                            this.displayPopup("Error", "No rooms left");
                        } else {
                            this.displayPopup("Error", "Something went wrong");
                            console.error(e);
                        }
                    }
                },
                async connect(code, keyMaterial) {
                    try {
                        const [ws, key] = await Promise.all([
                            connectToRoom(code),
                            readKey(keyMaterial),
                        ])

                        ws.send(await createMessage(key, Uint8Array.of(1, 0, 1)))

                        const message = await parseMessage(key, await readDataFromWs(ws));

                        if(new Uint8Array(message).join("") !== '101') {
                            console.error("Fake hello");
                            return;
                        }

                        this.setUpChat(key, ws);
                    } catch(e) {
                        if(e === 4002) {
                            this.displayPopup("Error", "Room not found");
                        } else {
                            this.displayPopup("Error", "Something went wrong");
                            console.error(e);
                        }
                    }
                },
                async initRelay(code, keyMaterial) {
                    let savedInvite;

                    try {
                        savedInvite = JSON.parse(localStorage.getItem("relayData"));
                    } catch {
                        savedInvite = null;
                    }

                    if(!savedInvite || Date.now() - savedInvite.date > 10 * 60 * 1000) {
                        localStorage.setItem("relayData", JSON.stringify({ code, keyMaterial, date: Date.now() }));

                        this.displayPopup(
                            "Relay initiated", 
                            "Scan second QR code to connect devices", 
                            true,
                            "Cancel",
                            () => {
                                localStorage.removeItem("relayData");

                                this.displayPopup("Connection stopped", null, false);
                            }
                        );

                        return;
                    }

                    this.displayPopup("Connecting devices...", null, false);

                    localStorage.removeItem("relayData");

                    const [ws, key, targetKeyBytes] = await Promise.all([
                        connectToRoom(code),
                        readKey(keyMaterial),
                        decodeBase64(savedInvite.keyMaterial)
                    ]);

                    const targetRoomCode = encoder.encode(savedInvite.code);

                    ws.send(await createMessage(key, Uint8Array.of(1, 0, 1, 0))); // 0 you are to start the negotiation

                    const message = await parseMessage(key, await readDataFromWs(ws));

                    if(new Uint8Array(message).join("") !== '101') {
                        console.error("Fake hello");
                        return;
                    }

                    const payload = new Uint8Array(targetKeyBytes.byteLength + targetRoomCode.byteLength);

                    payload.set(targetRoomCode);
                    payload.set(new Uint8Array(targetKeyBytes), targetRoomCode.byteLength);

                    ws.send(await createMessage(key, payload.buffer));
                    ws.close();

                    this.displayPopup("Invites are sent", "Check connecting devices", false);
                },
                /**
                 * @param {WebSocket} relayWs
                 */
                async startNegotiation(relayKey, relayWs) {
                    this.displayPopup("Connecting...", null, false);

                    const targetData = new Uint8Array(await parseMessage(relayKey, await readDataFromWs(relayWs)));
                    if(relayWs.readyState !== relayWs.CLOSED) {
                        relayWs.close();
                    }
                    
                    const code = decoder.decode(targetData.slice(0, 4));
                    const rawKeyBytes = targetData.slice(4);

                    const ecdhTask = generateECDH();

                    const [ws, key] = await Promise.all([
                        connectToRoom(code),
                        crypto.subtle.importKey(
                            "raw",
                            rawKeyBytes,
                            { name: 'AES-GCM', length: 128 },
                            false,
                            ['encrypt', 'decrypt'],
                        )
                    ])

                    ws.send(await createMessage(key, Uint8Array.of(1, 0, 1, 1))) // 1 for we are starting the negotiation

                    while(true) {
                        const hello = await parseMessage(key, await readDataFromWs(ws));

                        if(new Uint8Array(hello).join("") !== "101") {
                            console.error("Fake hello");
                            continue;
                        }

                        break;
                    }

                    const { privateKey, publicKey } = await ecdhTask;

                    ws.send(await createMessage(key, publicKey));

                    const theirPublicKeyBytes = await parseMessage(key, await readDataFromWs(ws));

                    const newKey = await deriveAESKey(theirPublicKeyBytes, privateKey);

                    this.setUpChat(newKey, ws);
                },
                async acceptNegotiation(key, ws) {
                    this.displayPopup("Connecting...", null, false);

                    const [{ privateKey, publicKey }, theirPublicKeyBytes] = await Promise.all([
                        generateECDH(),
                        readDataFromWs(ws)
                            .then(data => parseMessage(key, data))
                    ]);

                    ws.send(await createMessage(key, publicKey));

                    const newKey = await deriveAESKey(theirPublicKeyBytes, privateKey);
                    
                    this.setUpChat(newKey, ws);
                },
                async setUpChat(key, ws) {
                    this.ws = ws;
                    this.key = key;
                    this.messages = [];

                    this.stage = "chat";

                    this.ws.onmessage = async ({ data }) => {
                        const message = await parseMessage(key, data);

                        this.messages.push({ author: "THEM", text: decoder.decode(message) });
                    }

                    this.ws.onclose = ({ code }) => {
                        if(code === 1000) {
                            this.displayPopup("Chat closed", "Other party has left the room");
                        } else {
                            this.displayPopup("Chat closed", "Network error");
                        }
                    }
                },
                async sendMessage() {
                    if(!this.input) return;

                    const msg = await createMessage(this.key, encoder.encode(this.input));
                    this.ws.send(msg);

                    this.messages.push({ author: "ME", text: this.input });

                    this.input = "";
                },
                displayPopup(title, message, showRestart = true, buttonText = "Restart", buttonClickCb = this.createRoom) {
                    this.stage = "popup";

                    this.popup.title = title;
                    this.popup.message = message;
                    this.popup.showRestart = showRestart;
                    this.popup.buttonText = buttonText;
                    this.popup.buttonClickCb = buttonClickCb;
                }
            },
            async mounted() {
                document.getElementById('content').style.display = 'flex';

                const searchParams = new URLSearchParams(location.search);

                const code = searchParams.get("code");
                const key = searchParams.get("key");
                const relay = searchParams.get("relay");

                if(!code || !key) {
                    this.stage = 'creating';
                    this.createRoom();
                    return;
                }

                if(relay) this.initRelay(code, key)
                else this.connect(code, key);
            }
        })

        app.mount("#app")
    </script>
    <style>
        .form {
            background-color: var(--light-purple);

            width: 400px;

            padding: 10px;

            border-radius: 20px;

            position: relative;
        }

        @media screen and (max-width: 400px) {
            .form {
                width: 100vw;

                border-radius: 0;
            }

            .message {
                padding: 0 10px;
            }
        }

        .form-header {
            position: absolute;
            bottom: calc(100% + 15px);
            left: 0;

            width: 100%;

            color: var(--light-purple);
            font-size: 32px;
            line-height: 30px;
            margin: 0;
            text-align: center;

            position: absolute;
        }

        .form-button {
            display: block;

            width: 100%;

            border: none;
            border-radius: 20px;
            padding: 0;

            text-align: center;
            font-size: 20px;
            padding: 12px 0;
            color: var(--orange);

            background-color: var(--dark-purple);

            cursor: pointer;

            transition: color .3s, background .3s, transform .3s, box-shadow .3s;
        }

        .form-button:hover {
            background-color: var(--orange);
            color: var(--dark-purple);
            transform: translateY(-5px);
            box-shadow: 0 5px 0 var(--dark-purple);
        }

        .form-button:active {
            background-color: var(--orange);
            color: var(--dark-purple);
            transform: translateY(0px);
            box-shadow: 0 0 0 var(--dark-purple);
        }

        .form-input {
            width: 100%;

            background-color: var(--dark-purple);

            border: 2px solid var(--dark-purple);

            border-radius: 20px;

            outline: none;

            font-size: 20px;
            color: var(--orange);

            padding: 10px 15px;

            transition: border .3s;
        }

        .form-input:focus {
            border: 2px solid var(--orange);
        }

        .relay-container {
            position: absolute;
            left: 0;
            top: calc(100% + 10px);

            width: 100%;

            transition: transform .3s, opacity .3s;
        }

        .relay-container--visible {
            transform: translateY(0);
            opacity: 1;
        }

        .relay-container--hidden {
            transform: translateY(10px);
            opacity: 0;
        }

        .form-checkbox {
            cursor: pointer;

            display: flex;
            align-items: center;
            
            user-select: none;
        }

        .form-checkbox input[type="checkbox"] {
            display: none;
        }

        .checkbox-view {
            width: 20px;
            height: 20px;

            background-color: var(--dark-purple);
            border-radius: 50%;

            position: relative;
        }

        .checkbox-view::after {
            content: "";
            display: block;

            position: absolute;
            top: 5px;
            left: 5px;
            
            width: 10px;
            height: 10px;

            border-radius: 50%;

            background: transparent;
        }

        input[type="checkbox"]:checked + .checkbox-view::after {
            background-color: var(--orange);
        }

        .form-checkbox span {
            margin-left: 10px;

            color: var(--dark-purple);
            font-size: 16px;

            padding-bottom: 2px;
        }

        .messages {
            position: absolute;
            width: 100%;
            left: 0;
            bottom: calc(100% + 60px);
        }

        .message {
            width: 100%;

            display: flex;
            
            font-size: 16px;

            animation: message-pop .5s forwards;
        }

        @keyframes message-pop {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message:not(:first-child) {
            margin-top: 10px;
        }

        .message-me {
            justify-content: flex-end;

            color: var(--orange);
        }

        .message-them {
            justify-content: flex-start;

            color: var(--dark-purple);
        }

        .message-them .message-content {
            background-color: var(--light-purple);
        }

        .message-content {
            max-width: 60%;

            padding: 10px 15px;

            border-radius: 20px;

            box-shadow: 0 4px 0 1px black;

            border: 2px solid var(--light-purple);
        }
    </style>
</body>
</html>