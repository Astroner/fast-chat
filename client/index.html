<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.5.1/qrcode.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Noto+Sans+JP:wght@100..900&display=swap" rel="stylesheet">
    <title>Fast Chat</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: "Noto Sans JP", serif;
        }

        body {
            padding: 0;
            margin: 0;

            --black: #000;
            --dark-purple: #575068;
            --orange: #f29a30;
            --light-purple: #e1d8ef;

            background-color: var(--dark-purple);
        }
        .container {
            display: flex;
            align-items: center;
            justify-content: center;

            width: 100vw;
            height: 100vh;
        }

        .fade-in {
            animation: fade-in .3s forwards;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="stage === 'init'" class="container">
            <h2 class="fade-in" style="color: var(--light-purple); font-size: 32px;">Connecting</h2>
        </div>

        <div id="content" class="container" style="display: none;">
            <div v-if="stage === 'creating'">
                <h2 class="fade-in" style="color: var(--light-purple); font-size: 32px;">Creating a room</h2>
            </div>
            <div v-if="stage === 'invite'" class="form">
                <h2 class="form-header">Room QR</h2>
                <img :src="qrCode" style="width: 100%;">
            </div>
            <form v-if="stage === 'chat'" class="form" @submit.prevent="sendMessage">
                <h2 class="form-header">Chat</h2>
                <input class="form-input" placeholder="Enter message" v-model="input">
                <button class="form-button" style="margin-top: 10px;" type="submit">Send</button>
                <div class="messages">
                    <div v-for="message in messages" :class="{ message: true, 'message-me': message.author === 'ME', 'message-them': message.author === 'THEM' }">
                        <div class="message-content">
                            {{ message.text }}
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <script>
        // Helpers
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();

        /**
         * @returns {Promise<{ ws: WebSocket, code: string }>}
         */
        const createRoom = () => new Promise((resolve, reject) => {
            const ws = new WebSocket("/connect");
            ws.binaryType = "arraybuffer";

            const listener = (ev) => {
                resolve({ code: ev.data, ws })
                ws.removeEventListener('message', listener);
            };

            ws.addEventListener('message', listener);
        })

        /**
         * @param {string} code
         * @returns {Promise<WebSocket>}
         */
        const connectToRoom = (code) => new Promise((resolve, reject) => {
            const ws = new WebSocket(`/connect?code=${code}`);
            ws.binaryType = "arraybuffer";

            ws.onopen = () => {
                resolve(ws)
            }
        })

        /**
         * @returns {Promise<{ key: CryptoKey, base64: string }>}
         */
        const createKey = () => new Promise(async (resolve, reject) => {
            const key = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 128 },
                true,
                ['encrypt', 'decrypt'],
            );

            const keyBytes = await crypto.subtle.exportKey("raw", key);

            const blob = new Blob([keyBytes], { type: 'application/octet-binary' });

            const reader = new FileReader();

            reader.onload = (e) => {
                resolve({
                    key, 
                    base64: e.target.result.split(',')[1]
                })
            }

            reader.readAsDataURL(blob);
        })

        const readKey = async (keyMaterial) => {
            const dataURL = `data:application/octet-bytes;base64,` + keyMaterial;

            const res = await fetch(dataURL);

            const bytes = await res.arrayBuffer()

            return crypto.subtle.importKey(
                "raw",
                bytes,
                { name: 'AES-GCM', length: 128 },
                false,
                ['encrypt', 'decrypt'],
            )
        }

        /**
         * @param {CryptoKey} key
         * @param {ArrayBuffer} data
         * @returns {Promise<ArrayBuffer>}
         */
        const createMessage = async (key, data) => {
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const cipherText = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                key,
                data
            )

            const result = new Uint8Array(iv.byteLength + cipherText.byteLength);

            result.set(iv, 0);
            result.set(new Uint8Array(cipherText), 12);

            return result.buffer;
        }

        const parseMessage = async (key, message) => {
            const iv = message.slice(0, 12);
            const cipherText = message.slice(12);

            return crypto.subtle.decrypt(
                { name: "AES-GCM", iv },
                key,
                cipherText
            )
        }
    </script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    stage: "init",
                    qrCode: null,
                    messages: [
                        { author: "ME", text: "HI" },
                        { author: "THEM", text: "HI" },
                        { author: "ME", text: "HI" },
                        { author: "THEM", text: "HI" },
                        { author: "ME", text: "HI" },
                        { author: "THEM", text: "HI" },
                        { author: "ME", text: "HI" },
                        { author: "THEM", text: "HI" },
                        { author: "ME", text: "HI" },
                        { author: "THEM", text: "HI" },
                        { author: "ME", text: "HI" },
                        { author: "THEM", text: "HI" },
                    ],
                    input: ""
                }
            },
            methods: {
                async createRoom() {
                    const [{ key, base64 }, { code, ws }] = await Promise.all([
                        createKey(),
                        createRoom()
                    ]);

                    const url = new URL(location.origin);
                    url.searchParams.set("code", code);
                    url.searchParams.set("key", base64);

                    console.log(url.toString());

                    const qr = await QRCode.toDataURL(url.toString(), {
                        type: 'image/png',
                        color: {
                            dark: "#575068",
                            light: "#e1d8ef"
                        }
                    });

                    this.qrCode = qr;
                    this.stage = "invite"

                    ws.onmessage = async (e) => {
                        try {
                            const message = await parseMessage(key, e.data);
                            if(new Uint8Array(message).join("") !== '101') {
                                console.error("Fake hello");
                                return;
                            }

                            ws.send(await createMessage(key, Uint8Array.of(1, 0, 1)))

                            ws.onmessage = null;
                            this.setUpChat(key, ws);

                        } catch(e) {
                            console.error(e)
                        }
                    };
                },
                async connect(code, keyMaterial) {
                    const [ws, key] = await Promise.all([
                        connectToRoom(code),
                        readKey(keyMaterial),
                    ])

                    ws.onmessage = async (e) => {
                        const message = await parseMessage(key, e.data);

                        if(new Uint8Array(message).join("") !== '101') {
                            console.error("Fake hello");
                            return;
                        }

                        ws.onmessage = null;
                        this.setUpChat(key, ws);
                    }

                    const message = await createMessage(key, Uint8Array.of(1, 0, 1))

                    ws.send(message)
                },
                async setUpChat(key, ws) {
                    this.ws = ws;
                    this.key = key;
                    this.messages = [];

                    this.stage = "chat";

                    this.ws.onmessage = async ({ data }) => {
                        const message = await parseMessage(key, data);

                        this.messages.push({ author: "THEM", text: decoder.decode(message) });
                    }
                },
                async sendMessage() {
                    if(!this.input) return;

                    const msg = await createMessage(this.key, encoder.encode(this.input));
                    this.ws.send(msg);

                    this.messages.push({ author: "ME", text: this.input });

                    this.input = "";
                }
            },
            async mounted() {
                document.getElementById('content').style.display = 'flex';

                const searchParams = new URLSearchParams(location.search);

                const code = searchParams.get("code");
                const key = searchParams.get("key");

                if(!code || !key) {
                    this.stage = 'creating';
                    this.createRoom();
                    return;
                }

                this.connect(code, key);
            }
        })

        app.mount("#app")
    </script>
    <style>
        .form {
            background-color: var(--light-purple);

            width: 400px;

            padding: 10px;

            border-radius: 20px;

            position: relative;
        }

        @media screen and (max-width: 400px) {
            .form {
                width: 100vw;

                border-radius: 0;
            }

            .message {
                padding: 0 10px;
            }
        }

        .form-header {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 0;

            width: 100%;

            color: var(--light-purple);
            font-size: 32px;
            line-height: 30px;
            margin: 0;
            text-align: center;

            position: absolute;
        }

        .form-button {
            display: block;

            width: 100%;

            border: none;
            border-radius: 20px;
            padding: 0;

            text-align: center;
            font-size: 20px;
            padding: 12px 0;
            color: var(--orange);

            background-color: var(--dark-purple);

            cursor: pointer;

            transition: color .3s, background .3s, transform .3s, box-shadow .3s;
        }

        .form-button:hover {
            background-color: var(--orange);
            color: var(--dark-purple);
            transform: translateY(-5px);
            box-shadow: 0 5px 0 var(--dark-purple);
        }

        .form-button:active {
            background-color: var(--orange);
            color: var(--dark-purple);
            transform: translateY(0px);
            box-shadow: 0 0 0 var(--dark-purple);
        }

        .form-input {
            width: 100%;

            background-color: var(--dark-purple);

            border: 2px solid var(--dark-purple);

            border-radius: 20px;

            outline: none;

            font-size: 20px;
            color: var(--orange);

            padding: 10px 15px;

            transition: border .3s;
        }

        .form-input:focus {
            border: 2px solid var(--orange);
        }

        .messages {
            position: absolute;
            width: 100%;
            left: 0;
            bottom: calc(100% + 60px);
        }

        .message {
            width: 100%;

            display: flex;
            
            font-size: 16px;

            animation: message-pop .5s forwards;
        }

        @keyframes message-pop {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message:not(:first-child) {
            margin-top: 10px;
        }

        .message-me {
            justify-content: flex-end;

            color: var(--orange);
        }

        .message-them {
            justify-content: flex-start;

            color: var(--dark-purple);
        }

        .message-them .message-content {
            background-color: var(--light-purple);
        }

        .message-content {
            max-width: 60%;

            padding: 10px 15px;

            border-radius: 20px;

            box-shadow: 0 4px 0 1px black;

            border: 2px solid var(--light-purple);
        }
    </style>
</body>
</html>